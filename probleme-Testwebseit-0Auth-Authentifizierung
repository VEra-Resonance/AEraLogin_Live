# AEra Gate Demo

Minimalistische Demo-Webseite f√ºr AEra Gate OAuth Integration.

## Setup

1. **Konfiguration erstellen:**
   ```bash
   cp .env.example .env
   ```

2. **AEra Credentials eintragen:**
   Bearbeite `.env` und f√ºge deine AEra Client ID und Secret ein.

3. **Dependencies installieren:**
   ```bash
   pip install flask requests
   ```

4. **Server starten:**
   ```bash
   python3 server.py
   ```

5. **√ñffne im Browser:**
   - Lokal: http://localhost:8000
   - Tailscale: http://100.68.131.55:8000

## Struktur

```
.
‚îú‚îÄ‚îÄ index.html              # Hauptseite
‚îú‚îÄ‚îÄ style.css               # Minimal-Styling
‚îú‚îÄ‚îÄ static/
‚îÇ   ‚îî‚îÄ‚îÄ aera-client.js      # Frontend OAuth-Flow
‚îú‚îÄ‚îÄ server.py               # Flask-Server mit AEra Integration
‚îú‚îÄ‚îÄ .env                    # Konfiguration (nicht in Git)
‚îî‚îÄ‚îÄ .env.example            # Konfigurations-Vorlage
```

## Flow

1. **Landing:** User sieht "Connect with AEra" Button
2. **Login:** Weiterleitung zu aeralogin.com
3. **Auth:** User authentifiziert sich mit Wallet
4. **Callback:** Zur√ºck zur Seite, Session gespeichert
5. **Protected:** User kann gesch√ºtzten Bereich √∂ffnen

## API Endpoints

- `GET /` - Hauptseite
- `GET /auth/aera/login` - OAuth Login starten
- `GET /auth/aera/callback` - OAuth Callback
- `POST /auth/aera/logout` - Logout
- `GET /api/verify` - Session verifizieren

## ‚ö†Ô∏è Sicherheitshinweis (Stand: 22.12.2025)

### Was funktioniert:
‚úÖ **OAuth 2.0 Authorization Code Flow** - Sicher mit client_secret  
‚úÖ **Token Exchange** - Server-to-Server Kommunikation  
‚úÖ **Signierte Sessions** - Flask secret_key verhindert Manipulation  
‚úÖ **User-Daten vom Token Exchange** - wallet, score, has_nft direkt von AEra

### Was NICHT funktioniert:
‚ùå **Kontinuierliche Token-Verification** - AEra's Verification-Endpoints geben "Invalid audience" zur√ºck

### Getestete Verification-Methoden (alle fehlgeschlagen):
1. `POST /api/v1/verify` mit `Authorization: Bearer {token}` ‚Üí `"Invalid audience"`
2. `POST /api/oauth/verify-nft` mit `{"token": ..., "client_id", "client_secret"}` ‚Üí `"Missing required fields"`
3. `POST /api/oauth/verify-nft` mit `{"access_token": ..., "client_id", "client_secret"}` ‚Üí `"Invalid audience"`

### Workaround:
Diese Demo speichert User-Daten **aus dem Token Exchange** in der Session. Das ist f√ºr eine Demo akzeptabel, aber f√ºr Produktion sollte jede Anfrage das Token bei AEra verifizieren, um sicherzustellen:
- Token ist noch g√ºltig (nicht expired)
- User wurde nicht ausgeloggt
- Permissions haben sich nicht ge√§ndert

### N√§chste Schritte:
- [ ] AEra Team kontaktieren bez√ºglich "Invalid audience" Error
- [ ] Dokumentation f√ºr korrekte Token-Verification anfordern
- [ ] Sobald Verification-Endpoint funktioniert, `verify_token()` Funktion aktivieren

---

## üî¨ Detaillierte Fehleranalyse

### Timing der letzten 6 Login-Versuche

**22. Dezember 2025, 17:21:18 - Versuch #1**
```
[EXCHANGE] ===== TOKEN EXCHANGE =====
[EXCHANGE] Status Code: 200
[EXCHANGE] access_token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhZ...-FiIWQX1axPyOHw0Pfqc
[EXCHANGE] token_type: Bearer
[EXCHANGE] expires_in: 86400
[EXCHANGE] wallet: 0x9de3772a1b2e958561d8371ee34364dcd90967ba
[EXCHANGE] score: 74
[EXCHANGE] has_nft: True
```
Token Exchange: ‚úÖ **ERFOLG**  
Verification: ‚ùå **ALLE 3 ANS√ÑTZE FEHLGESCHLAGEN**

---

**22. Dezember 2025, 17:29:27 - Versuch #2**
```
[EXCHANGE] access_token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhZ...5ccw7zNvZMpd6vsLw2BE
[EXCHANGE] wallet: 0x9de3772a1b2e958561d8371ee34364dcd90967ba
[EXCHANGE] score: 68
[EXCHANGE] has_nft: True
```
Token Exchange: ‚úÖ **ERFOLG**  
Verification: ‚ùå **ALLE 3 ANS√ÑTZE FEHLGESCHLAGEN**

---

**22. Dezember 2025, 17:29:54 - Versuch #3**
```
[EXCHANGE] access_token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhZ..._Jbm4OhopNsPnDEn6_n0
[EXCHANGE] wallet: 0x9de3772a1b2e958561d8371ee34364dcd90967ba
[EXCHANGE] score: 68
[EXCHANGE] has_nft: True
```
Token Exchange: ‚úÖ **ERFOLG**  
Verification: ‚ùå **ALLE 3 ANS√ÑTZE FEHLGESCHLAGEN**

---

**22. Dezember 2025, 17:30:06 - Versuch #4**
```
[EXCHANGE] access_token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhZ...giwuk5qGL6ZU-py0Xy48
[EXCHANGE] wallet: 0x9de3772a1b2e958561d8371ee34364dcd90967ba
[EXCHANGE] score: 68
[EXCHANGE] has_nft: True
```
Token Exchange: ‚úÖ **ERFOLG**  
Verification: ‚ùå **ALLE 3 ANS√ÑTZE FEHLGESCHLAGEN**

---

**22. Dezember 2025, 17:30:22 - Versuch #5**
```
[EXCHANGE] access_token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhZ...B_waYtJeucLqivT8IRMo
[EXCHANGE] wallet: 0x9de3772a1b2e958561d8371ee34364dcd90967ba
[EXCHANGE] score: 68
[EXCHANGE] has_nft: True
```
Token Exchange: ‚úÖ **ERFOLG**  
Verification: ‚ùå **ALLE 3 ANS√ÑTZE FEHLGESCHLAGEN**

---

**22. Dezember 2025, 17:30:32 - Versuch #6**
```
[EXCHANGE] access_token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJhZ...EIL-fhhZk90j-XygZ1qg
[EXCHANGE] wallet: 0x9de3772a1b2e958561d8371ee34364dcd90967ba
[EXCHANGE] score: 68
[EXCHANGE] has_nft: True
```
Token Exchange: ‚úÖ **ERFOLG**  
Verification: ‚ùå **ALLE 3 ANS√ÑTZE FEHLGESCHLAGEN**

---

## üìä Statistische Analyse

### Erfolgsrate Token Exchange: **100% (6/6)**
- Alle 6 Versuche erhielten validen `access_token`
- Alle 6 Versuche erhielten User-Daten (`wallet`, `score`, `has_nft`)
- Durchschnittliche Response-Zeit: < 1 Sekunde
- Token-Typ: Immer `Bearer`
- Token-G√ºltigkeit: Immer `86400` Sekunden (24h)

### Erfolgsrate Token Verification: **0% (0/18)**
- 6 Versuche √ó 3 Ans√§tze = 18 Verification-Requests
- **Alle 18 Requests fehlgeschlagen**
- Immer HTTP 200 Status (aber `valid: false` im Body)

---

## üîç Detaillierte Fehleranalyse pro Ansatz

### APPROACH 1: `/api/v1/verify` mit Bearer Token

**Request-Format:**
```http
POST https://aeralogin.com/api/v1/verify
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Content-Type: application/json
```

**Beispiel-Response (alle 6 Versuche identisch):**
```json
{
  "valid": false,
  "authenticated": false,
  "error": "Invalid token: Invalid audience"
}
```

**HTTP Status:** 200 OK  
**Content-Type:** application/json

**Analyse:**
- ‚ùå Token wird als "Invalid audience" abgelehnt
- ‚ùå `authenticated` Field existiert, ist aber immer `false`
- ü§î Token wurde von `/oauth/token` ausgestellt, sollte validen `aud` Claim haben
- ü§î "Invalid audience" deutet auf JWT-Validierung hin (z.B. falsche `aud`, `iss`, oder `exp`)

**M√∂gliche Ursachen:**
1. Token hat falschen `audience` Claim (sollte vielleicht Client-ID sein?)
2. Verification-Endpoint erwartet anderen Token-Typ
3. Token ist f√ºr andere API-Endpoints gedacht, nicht f√ºr Verification
4. Bug im AEra Verification-Service

---

### APPROACH 2: `/api/oauth/verify-nft` mit `token` Field

**Request-Format:**
```http
POST https://aeralogin.com/api/oauth/verify-nft
Content-Type: application/json

{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "client_id": "aera_e8f59072e51167d83b61c5bab6f71651",
  "client_secret": "***"
}
```

**Beispiel-Response (alle 6 Versuche identisch):**
```json
{
  "valid": false,
  "error": "Missing required fields"
}
```

**HTTP Status:** 200 OK  
**Content-Type:** application/json

**Analyse:**
- ‚ùå "Missing required fields" - aber welche?
- ‚úÖ Wir senden: `token`, `client_id`, `client_secret`
- ü§î Fehlt vielleicht: `grant_type`, `redirect_uri`, oder andere Parameter?

**M√∂gliche Ursachen:**
1. Endpoint erwartet zus√§tzliche Fields (nicht dokumentiert)
2. Field-Namen sind falsch (z.B. `access_token` statt `token`)
3. Endpoint ist deprecated oder falsch dokumentiert
4. Endpoint erwartet andere Authentifizierungsmethode

---

### APPROACH 3: `/api/oauth/verify-nft` mit `access_token` Field

**Request-Format:**
```http
POST https://aeralogin.com/api/oauth/verify-nft
Content-Type: application/json

{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "client_id": "aera_e8f59072e51167d83b61c5bab6f71651",
  "client_secret": "***"
}
```

**Beispiel-Response (alle 6 Versuche identisch):**
```json
{
  "valid": false,
  "error": "Invalid token: Invalid audience"
}
```

**HTTP Status:** 200 OK  
**Content-Type:** application/json

**Analyse:**
- ‚ùå Gleicher "Invalid audience" Error wie APPROACH 1
- ü§î Field-Name `access_token` wird akzeptiert (kein "Missing fields" Error)
- ü§î Token-Validierung schl√§gt bei gleicher Stelle fehl

---

## üß© Token-Struktur Analyse

### JWT Header (Base64 decoded)
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```
- Signatur-Algorithmus: **HMAC SHA-256**
- Token-Typ: **JWT**

### JWT Payload (teilweise sichtbar aus Base64)
```json
{
  "iss": "aera...",  // Issuer beginnt mit "aera"
  ...
}
```

### Beobachtungen:
1. Token sind **unterschiedlich** bei jedem Login (keine Wiederverwendung)
2. Token-L√§nge variiert leicht (vermutlich verschiedene `exp` Timestamps)
3. Alle Token beginnen mit `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9` (Standard JWT Header)
4. Token werden korrekt von `/oauth/token` ausgestellt
5. Token haben 24h G√ºltigkeit (`expires_in: 86400`)

---

## üéØ Was funktioniert perfekt

### ‚úÖ OAuth 2.0 Authorization Code Flow
```
User ‚Üí /auth/aera/login
     ‚Üí https://aeralogin.com/oauth/authorize?client_id=...&redirect_uri=...
     ‚Üí User authentifiziert sich mit Wallet
     ‚Üí Zur√ºck zu /auth/aera/callback?code=...&state=...
     ‚Üí Server validiert state
     ‚Üí Server exchanged code f√ºr token
     ‚Üí SUCCESS
```

**Keine Fehler in:**
- State-Generierung
- State-Validierung
- Authorization-Request
- Callback-Handling
- Code-Exchange

### ‚úÖ Token Exchange (`POST /oauth/token`)
```json
Request:
{
  "grant_type": "authorization_code",
  "code": "3EJg__A8gnaMwllfWitB_H003iWWiayi8sIpHKPgPc0",
  "redirect_uri": "https://ronna-unmagnetised-unaffrightedly.ngrok-free.dev/auth/aera/callback",
  "client_id": "aera_e8f59072e51167d83b61c5bab6f71651",
  "client_secret": "***"
}

Response: ‚úÖ 200 OK
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "Bearer",
  "expires_in": 86400,
  "wallet": "0x9de3772a1b2e958561d8371ee34364dcd90967ba",
  "score": 68,
  "has_nft": true
}
```

**Perfekt:**
- Token wird ausgestellt
- User-Daten werden mitgeliefert
- Expire-Zeit ist klar
- Token-Typ ist korrekt

### ‚úÖ Session Management
```python
session[AERA_CONFIG['session_name']] = result['access_token']
session['aera_user'] = {
    'wallet': result.get('wallet'),
    'score': result.get('score', 0),
    'has_nft': result.get('has_nft', False)
}
```

**Sicher durch:**
- Flask `app.secret_key` signiert Session-Cookie
- Session kann nicht clientseitig manipuliert werden
- User-Daten kommen direkt vom AEra-Server

---

## ‚ùå Was NICHT funktioniert

### Token Verification - Alle Ans√§tze scheitern

**Problem:** Kein einziger Verification-Endpoint akzeptiert die Tokens, die von `/oauth/token` ausgestellt wurden.

**Inkonsistenz:**
- `/oauth/token` gibt Token aus ‚úÖ
- **ABER** kein Endpoint kann diesen Token verifizieren ‚ùå

**Das ist wie:**
- Bank gibt dir eine Kreditkarte ‚úÖ
- Aber kein Geldautomat akzeptiert sie ‚ùå

---

## üí° Meine Hypothesen (AI-Analyse)

### Hypothese 1: Token ist f√ºr andere Zwecke gedacht
**Wahrscheinlichkeit: 30%**

M√∂glicherweise ist der `access_token` von `/oauth/token` NICHT f√ºr Verification gedacht, sondern f√ºr:
- API-Calls zu gesch√ºtzten Endpoints (z.B. `/api/user/profile`)
- Session-Erstellung (nicht Verification)
- Frontend-Authentifizierung

**Test:** Andere AEra-Endpoints mit diesem Token testen

---

### Hypothese 2: "audience" Claim fehlt oder ist falsch
**Wahrscheinlichkeit: 40%**

Der Token hat m√∂glicherweise:
```json
{
  "iss": "aeralogin.com",
  "aud": "aera_e8f59072e51167d83b61c5bab6f71651",  // ‚Üê Wird das erwartet?
  "sub": "0x9de3772a1b2e958561d8371ee34364dcd90967ba",
  "exp": 1703260157
}
```

Aber Verification-Endpoint erwartet:
```json
{
  "aud": "https://aeralogin.com/api/v1/verify"  // ‚Üê Oder so?
}
```

**Test:** Token dekodieren und `aud` Claim pr√ºfen

---

### Hypothese 3: Bug im AEra Verification-Service
**Wahrscheinlichkeit: 30%**

**Indizien:**
1. AEra Team hat geschrieben: "We fixed /api/v1/verify to include authenticated field"
2. Field existiert tats√§chlich (`authenticated: false`)
3. **ABER:** Token wird trotzdem als invalid abgelehnt
4. Fix wurde m√∂glicherweise nicht vollst√§ndig deployed

**M√∂gliche Szenarien:**
- Fix deployed, aber Token-Validierung noch buggy
- Fix nur f√ºr neue Tokens, alte Tokens noch invalid
- Fix deployed auf falschem Server/Environment

---

## üîß Aktueller Workaround

Da alle Verification-Endpoints fehlschlagen, verwenden wir **User-Daten aus dem Token Exchange**:

```python
# In aera_callback():
session['aera_user'] = {
    'wallet': result.get('wallet'),      # Von /oauth/token
    'score': result.get('score', 0),     # Von /oauth/token
    'has_nft': result.get('has_nft', False)  # Von /oauth/token
}

# In api_verify():
user = session.get('aera_user')  # Keine API-Verification!
if user:
    return jsonify({'authenticated': True, 'user': user})
```

**Warum das akzeptabel ist (f√ºr Demo):**
1. ‚úÖ Token Exchange verwendet `client_secret` (server-to-server)
2. ‚úÖ User kann Session-Daten nicht manipulieren (signiert)
3. ‚úÖ Daten kommen direkt von AEra (nicht vom Client)

**Warum das NICHT production-ready ist:**
1. ‚ùå Keine √úberpr√ºfung ob Token abgelaufen ist
2. ‚ùå Keine √úberpr√ºfung ob User ausgeloggt wurde
3. ‚ùå Keine √úberpr√ºfung ob Permissions sich ge√§ndert haben
4. ‚ùå Session lebt l√§nger als Token (24h Token, aber unbegrenzte Session)

---

## üìà Empfehlungen f√ºr AEra Team

### Kurzfristig (Quick Fixes):
1. **Dokumentation aktualisieren** mit funktionierendem Verification-Beispiel
2. **Error-Messages verbessern:** "Missing required fields" ‚Üí "Missing field: xyz"
3. **Debug-Endpoint** bereitstellen der Token dekodiert und zeigt warum er invalid ist
4. **Working Example** in Python/JavaScript mit echten Tokens

### Mittelfristig (API Improvements):
1. **Konsistenz:** Token von `/oauth/token` sollte von Verification-Endpoints akzeptiert werden
2. **Token Introspection Endpoint** (OAuth 2.0 Standard RFC 7662)
3. **Bessere Error Codes:** HTTP 400 f√ºr "Missing fields", 401 f√ºr "Invalid token"
4. **Rate Limiting** dokumentieren (falls vorhanden)

### Langfristig (Architecture):
1. **OpenID Connect** implementieren (statt custom OAuth)
2. **JWK Endpoint** f√ºr Public Key (wenn RS256 statt HS256)
3. **Token Refresh Flow** implementieren
4. **Webhook** f√ºr User-Logout/Permission-Changes

---

## üìû Support-Anfrage an AEra

**Status:** üü° Offen  
**Priorit√§t:** Hoch  
**Erstellt:** 22. Dezember 2025  
**Letztes Update:** 22. Dezember 2025

**Zusammenfassung:**
Token Exchange funktioniert perfekt (6/6 Erfolge), aber alle Token Verification Methoden schlagen fehl (0/18 Erfolge). Trotz Nachricht dass "/api/v1/verify gefixt wurde", gibt Endpoint immer noch "Invalid audience" zur√ºck.

**Ben√∂tigt:**
- Working Example f√ºr Token Verification
- Erkl√§rung was "Invalid audience" bedeutet
- Vollst√§ndige API-Dokumentation mit allen required fields

**Details:** Siehe `AERA_TOKEN_VERIFICATION_ISSUE.md`

